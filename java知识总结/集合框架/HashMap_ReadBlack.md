# 红黑树总结
## 红黑树介绍
红黑树是一种自平衡二叉查找树，是计算机科学领域中的一种数据结构，典型的用途是实现关联数组，存储有序的数据。它是在1972年由Rudolf Bayer发明的，别称"对称二叉B树"，它现代的名字由 Leo J. Guibas 和 Robert Sedgewick 于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的。它可以在O(logn)时间内做查找，插入和删除，这里的n是树的结点个数。

红黑树和平衡二叉树(AVL树)都是二叉查找树的变体，但红黑树的统计性能要好于AVL树。因为，AVL树是严格维持平衡的，红黑树是黑平衡的。维持平衡需要额外的操作，这就加大了数据结构的时间复杂度，所以红黑树可以看作是二叉搜索树和AVL树的一个折中，维持平衡的同时也不需要花太多时间维护数据结构的性质。红黑树在很多地方都有应用，例如：
- C++的STL，map和set都是用红黑树实现的。
- 著名的linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块。
- epoll在内核中的实现，用红黑树管理事件块。
- nginx用红黑树管理timer等。
- Java的TreeMap实现。

### 红黑树的性质：
1. 所有节点要么是黑色要么是红色。
2. 根节点为黑色。
3. 所有叶子节点为黑色。 [注意：这里叶子结点，是指为空(NIL或NULL)的叶子结点！]
4. 如果一个节点是红色的，则它的子节点必须是黑色的。[也可以说成是不能要两个连续的红色节点。]
5. 每个结点到NIL叶子节点所经过的黑色节点数相同。
## 红黑树基本操作
红黑树的基本操作为**添加**和**删除**，删除和添加节点后有可能会破坏红黑树的特性，导致不满足上述的5个条件，而不再是一个红黑树，为了满足这5个条件，添加和删除节点后，需要通过**旋转**和**变色**来保证这5个条件，让该树继续为红黑树，二旋转又分为**左旋**和**右旋**。
### 左旋
以某个节点作为支点旋转，其右子节点旋转变为父节点，自己变为右子节点的左节点，右子节点的左子节点变为该节点的右子节点。
![rotateLeft](https://github.com/sunwnehongl/LearningSummary/blob/master/image/collection/rotateLeft.png "rotateLeft")

**左旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点x进行左旋”是如何进行的。**
```c
LEFT-ROTATE(T, x)  
01  y ← right[x]            // 前提：这里假设x的右孩子为y。下面开始正式操作
02  right[x] ← left[y]      // 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子
03  p[left[y]] ← x          // 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x
04  p[y] ← p[x]             // 将 “x的父亲” 设为 “y的父亲”
05  if p[x] = nil[T]       
06  then root[T] ← y                 // 情况1：如果 “x的父亲” 是空节点，则将y设为根节点
07  else if x = left[p[x]]  
08            then left[p[x]] ← y    // 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
09            else right[p[x]] ← y   // 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”
10  left[y] ← x             // 将 “x” 设为 “y的左孩子”
11  p[x] ← y                // 将 “x的父节点” 设为 “y”
```

### 右旋
以某个节点为支点，旋转其左子节点作为其父节点，自己做原左子节点的右子节点，原左子节点的右子节点作为该节点的左子节点。
![rotateLeft](https://github.com/sunwnehongl/LearningSummary/blob/master/image/collection/rotaterigth.png "rotaterigth")

**右旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点y进行右旋”是如何进行的。** 
```c
RIGHT-ROTATE(T, y)  
01  x ← left[y]             // 前提：这里假设y的左孩子为x。下面开始正式操作
02  left[y] ← right[x]      // 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子
03  p[right[x]] ← y         // 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y
04  p[x] ← p[y]             // 将 “y的父亲” 设为 “x的父亲”
05  if p[y] = nil[T]       
06  then root[T] ← x                 // 情况1：如果 “y的父亲” 是空节点，则将x设为根节点
07  else if y = right[p[y]]  
08            then right[p[y]] ← x   // 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”
09            else left[p[y]] ← x    // 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子”
10  right[x] ← y            // 将 “y” 设为 “x的右孩子”
11  p[y] ← x                // 将 “y的父节点” 设为 “x”
```
### 添加
插入算法
```c
RB-INSERT(T, z)  
 y ← nil[T]                        // 新建结点“y”，将y设为空结点。
 x ← root[T]                       // 设“红黑树T”的根结点为“x”
 while x ≠ nil[T]                  // 找出要插入的结点“z”在二叉树T中的位置（父结点），即“y”结点要存放的位置
     do y ← x                      
        if key[z] < key[x]  
           then x ← left[x]  
           else x ← right[x]  
 p[z] ← y                          // 设置 “z的父亲” 为 “y”
 if y = nil[T]                     
    then root[T] ← z               // 情景1：若y是空结点，则将z设为根结点
    else if key[z] < key[y]        
            then left[y] ← z       // 情景2：若“z的key值” < “y的key值”，则将z设为“y的左孩子”
            else right[y] ← z      // 情景2：若“z的key值” >= “y的key值”，则将z设为“y的右孩子” 
 left[z] ← nil[T]                  // z的左孩子设为空
 right[z] ← nil[T]                 // z的右孩子设为空。至此，已经完成将“结点z插入到二叉树”中了。
 color[z] ← RED                    // 将z着色为“红色”
 RB-INSERT-FIXUP(T, z)             // 通过RB-INSERT-FIXUP对红黑树的结点进行颜色修改以及旋转，让树T仍然是一颗红黑树
```
修正算法
```c
RB-INSERT-FIXUP(T, z)
 while color[p[z]] = RED                                            // 若“当前结点(z)的父结点是红色”，则进行以下处理。
    do if p[z] = left[p[p[z]]]                                      // 若“z的父结点”是“z的祖父结点的左孩子”，则进行以下处理。
          then y ← right[p[p[z]]]                                   // 将y设置为“z的叔叔结点(z的祖父结点的右孩子)”
            if color[y] = RED                                       // 4.1情景：叔叔是红色
              then color[p[z]] ← BLACK                              //  (01) 将“父结点”设为黑色。
                   color[y] ← BLACK                                 //  (02) 将“叔叔结点”设为黑色。
                   color[p[p[z]]] ← RED                             //  (03) 将“祖父结点”设为“红色”。
                   z ← p[p[z]]                                      //  (04) 将“祖父结点”设为“当前结点”(红色结点)
              else if z = right[p[z]]                               // 4.3.1情景：叔叔是黑色，且当前结点是右孩子
                    then z ← p[z]                                   //  (01) 将“父结点”作为“新的当前结点”。
                        LEFT-ROTATE(T, z)                           //  (02) 以“新的当前结点”为支点进行左旋。
                    color[p[z]] ← BLACK                             // 4.2.1情景：叔叔是黑色，且当前结点是左孩子。(01) 将“父结点”设为“黑色”。
                    color[p[p[z]]] ← RED                            //  (02) 将“祖父结点”设为“红色”。
                    RIGHT-ROTATE(T, p[p[z]])                        //  (03) 以“祖父结点”为支点进行右旋。
       else (same as then clause with "right" and "left" exchanged) // 若“z的父结点”是“z的祖父结点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。
 color[root[T]] ← BLACK                                             // 情景1：若y是空结点，则将z设为根结点
```
![节点插入](https://github.com/sunwnehongl/LearningSummary/blob/master/image/collection/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B5%E5%88%86%E7%B1%BB.png "节点插入")

新插入的节点颜色为红色，如果根节点为空、祖父节点为空、父节点为黑色则三中情况比较简单，因为直接插入不会破坏红黑树的特性，插入后还是满足红黑树的五个特性。

1. 所有节点要么是黑色要么是红色。
2. 根节点为黑色。
3. 所有叶子节点为黑色。 [注意：这里叶子结点，是指为空(NIL或NULL)的叶子结点！]
4. 如果一个节点是红色的，则它的子节点必须是黑色的。[也可以说成是不能要两个连续的红色节点。]
5. 每个结点到NIL叶子节点所经过的黑色节点数相同。
**父节点为红色并且叔叔节点为红色**
因为父节点为红色，新插入的节点叶也为红色，所以不满足条件4，其他条件都是满足的，如果我们破坏了这个条件那么改树就还是一颗红黑树，因为插入前父节点和叔叔节点都为红色，所以可以推断出祖父节点为黑色。试想下如果把祖父节点设置为黑色，父节点和叔叔节点设置为黑色，那么祖父节点还有其子树还是一颗红黑树，只是把祖父节点设置为红色，那么如果祖父节点的父节点如果为红色节点，就可能会导致不满足条件4，我们只要把祖父节点作为当前节点，继续通过旋转变色来保持就可以了。
**父节点为红色并且叔叔节点为黑色**
如果父节点为红色，叔叔节点为黑色，则可以推断出祖父节点为黑色，这种情况的核心思想就是

